name: PR File Analysis
on:
  pull_request:
    types: [opened, synchronize]
permissions:
  pull-requests: write
  contents: read
jobs:
  analyze-changes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to ensure we can access the changed files
      
      - name: Get changed files
        id: changed-files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path')
          echo "Changed files: $CHANGED_FILES"
          echo "CHANGED_FILES<<EOF" >> $GITHUB_ENV
          echo "$CHANGED_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      
      - name: Analyze files and post review comments
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          API_URL="https://bd10-154-125-8-19.ngrok-free.app/analyze/code"
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO="${GITHUB_REPOSITORY}"
          COMMIT_ID=$(gh pr view $PR_NUMBER --json commits --jq '.commits[-1].oid')
          
          echo "Latest commit ID: $COMMIT_ID"
          
          # Get existing PR comments to avoid duplication
          echo "Fetching existing comments..."
          EXISTING_COMMENTS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$REPO/pulls/$PR_NUMBER/comments")
          
          # Process each file individually
          for FILE in $CHANGED_FILES; do
            if [ -f "$FILE" ]; then
              echo "Processing file: $FILE"
              # Get file content and escape properly for JSON
              FILE_CONTENT=$(cat "$FILE" | jq -Rs .)
              # Create JSON payload for this file
              JSON_PAYLOAD="{\"code\": $FILE_CONTENT, \"filename\": \"$FILE\"}"
              echo "Sending request for $FILE..."
              
              # Send to API and capture response
              RESPONSE=$(curl -s -X POST "$API_URL" \
                -H "Content-Type: application/json" \
                -d "$JSON_PAYLOAD")
                
              echo "API Response for $FILE:"
              echo "$RESPONSE"
              
              # Parse issues from the response
              ISSUES=$(echo "$RESPONSE" | jq -r '.issues // []')
              
              # If there are issues, create comments for each
              if [[ "$ISSUES" != "[]" && "$ISSUES" != "null" ]]; then
                # Count issues
                ISSUE_COUNT=$(echo "$ISSUES" | jq 'length')
                echo "Found $ISSUE_COUNT issues for $FILE"
                
                # Create a review comment for each issue
                for (( i=0; i<$ISSUE_COUNT; i++ )); do
                  LINE=$(echo "$ISSUES" | jq -r ".[$i].line")
                  MESSAGE=$(echo "$ISSUES" | jq -r ".[$i].message")
                  TYPE=$(echo "$ISSUES" | jq -r ".[$i].type")
                  SOURCE=$(echo "$ISSUES" | jq -r ".[$i].source")
                  
                  # Create the review comment using the GitHub REST API
                  COMMENT_BODY="**$TYPE** from $SOURCE: $MESSAGE"
                  
                  # Check if this issue has already been commented on
                  IS_DUPLICATE=$(echo "$EXISTING_COMMENTS" | jq --arg body "$COMMENT_BODY" --arg path "$FILE" --arg line "$LINE" \
                    'map(select(.path == $path and .line == ($line|tonumber) and .body == $body)) | length')
                  
                  if [[ "$IS_DUPLICATE" == "0" ]]; then
                    echo "Adding new comment at $FILE:$LINE - $COMMENT_BODY"
                    
                    # Use GitHub REST API to post the review comment
                    curl -s -X POST \
                      -H "Authorization: token $GITHUB_TOKEN" \
                      -H "Accept: application/vnd.github.v3+json" \
                      "https://api.github.com/repos/$REPO/pulls/$PR_NUMBER/comments" \
                      -d "{
                        \"body\": \"$COMMENT_BODY\",
                        \"commit_id\": \"$COMMIT_ID\",
                        \"path\": \"$FILE\",
                        \"line\": $LINE
                      }"
                  else
                    echo "Skipping duplicate comment at $FILE:$LINE - already exists"
                  fi
                done
              else
                # No issues detected
                echo "No specific issues found for $FILE"
              fi
              
              echo "-----------------------------------"
            fi
          done
      
      - name: Add summary comment with overall analysis
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            # Code Analysis Summary
            
            Analysis completed for all changed files. See inline comments for details.
            
            *Automated analysis performed on changed files*
          comment_tag: code-analysis-summary
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Check for outdated comments (separate step)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e # Make script exit on any error
          
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO="${GITHUB_REPOSITORY}"
          API_URL="https://bd10-154-125-8-19.ngrok-free.app/analyze/code"
          
          echo "Checking for resolved issues..."
          
          # Get all existing review comments
          echo "Fetching all PR comments..."
          COMMENTS=$(gh api repos/$REPO/pulls/$PR_NUMBER/comments --paginate)
          if [ $? -ne 0 ]; then
            echo "Warning: Failed to fetch PR comments. Skipping cleanup."
            exit 0
          fi
          
          # Extract linter comments (those starting with **error, **warning, etc.)
          echo "Filtering linter comments..."
          LINTER_COMMENTS=$(echo "$COMMENTS" | jq '[.[] | select(.body | test("^\\*\\*[a-z]+\\*\\* from [a-z]+:"))]')
          
          # Get comment count
          COMMENT_COUNT=$(echo "$LINTER_COMMENTS" | jq 'length')
          echo "Found $COMMENT_COUNT linter comments"
          
          # For each linter comment, check if the issue still exists
          for (( i=0; i<$COMMENT_COUNT; i++ )); do
            COMMENT_ID=$(echo "$LINTER_COMMENTS" | jq -r ".[$i].id")
            COMMENT_PATH=$(echo "$LINTER_COMMENTS" | jq -r ".[$i].path")
            COMMENT_LINE=$(echo "$LINTER_COMMENTS" | jq -r ".[$i].line")
            COMMENT_BODY=$(echo "$LINTER_COMMENTS" | jq -r ".[$i].body")
            
            echo "Checking comment ID $COMMENT_ID at $COMMENT_PATH:$COMMENT_LINE"
            
            # Check if the file exists and was changed in this PR
            if [[ -f "$COMMENT_PATH" ]]; then
              echo "  File exists, re-analyzing..."
              
              # Re-analyze the file to see if issue still exists
              FILE_CONTENT=$(cat "$COMMENT_PATH" | jq -Rs .)
              JSON_PAYLOAD="{\"code\": $FILE_CONTENT, \"filename\": \"$COMMENT_PATH\"}"
              
              API_RESPONSE=$(curl -s -X POST "$API_URL" \
                -H "Content-Type: application/json" \
                -d "$JSON_PAYLOAD")
              
              if [ $? -ne 0 ] || [[ "$API_RESPONSE" == "" ]]; then 
                echo "  Warning: Failed to get API response. Skipping this comment."
                continue
              fi
              
              echo "  Got API response, checking if issue still exists..."
              NEW_ISSUES=$(echo "$API_RESPONSE" | jq -r '.issues // []')
              
              # Extract message from comment body (after the source: part)
              COMMENT_MESSAGE=$(echo "$COMMENT_BODY" | sed -E 's/^\*\*[^*]+\*\* from [^:]+: (.*)/\1/')
              
              # Check if this specific issue still exists at this line
              ISSUE_STILL_EXISTS=$(echo "$NEW_ISSUES" | jq --arg line "$COMMENT_LINE" --arg msg "$COMMENT_MESSAGE" \
                'map(select(.line == ($line|tonumber) and .message | contains($msg))) | length')
              
              if [[ "$ISSUE_STILL_EXISTS" == "0" ]]; then
                echo "  Issue fixed, removing comment $COMMENT_ID"
                # Delete the comment as the issue is fixed
                gh api -X DELETE repos/$REPO/pulls/comments/$COMMENT_ID
                if [ $? -ne 0 ]; then
                  echo "  Warning: Failed to delete comment $COMMENT_ID. Continuing..."
                fi
              else
                echo "  Issue still exists, keeping comment"
              fi
            else
              echo "  File not found, skipping"
            fi
          done
          
          # Always exit with success
          exit 0